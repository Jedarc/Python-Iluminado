# Módulos

**Módulo** é um arquivo que contém definições e comandos/instruções **Python**. 

Um módulo pode conter tanto instruções executáveis quanto definições de funções e classes. Essas instruções servem para inicializar o módulo. Eles são executados somente na primeira vez que o módulo é encontrado em uma instrução de importação.

Podemos dizer que os **módulos** são **bibliotecas** que podem nos ajudar com funções definidas para uso imediato, em outras palavras, para usarmos um módulo devemos compreender como utilizar suas **funções**, sem a necessidade de mergulharmos em **detalhes específicos** de implementação.

### Intuição dos Módulos

Também podemos imaginar um módulo como um conjunto de ferramentas disponíveis para usarmos para solucionar determinados problemas.

A figura a seguir ilustra esta ideia, onde temos um módulo chamado de **ferramentas**:

![img](https://raw.githubusercontent.com/the-akira/Python-Iluminado/master/Imagens/Modules.png)

Imagine agora que desejamos importar todas as ferramentas do módulo **ferramentas**, para isso, podemos usar o seguinte comando:

```python
import ferramentas
```

Agora pense em uma situação em que desejamos apenas importar uma ferramenta específica. Podemos expressar essa ideia da seguinte forma:

```python
from ferramentas import martelo
```

Também podemos importar mais de uma ferramenta, separando-as por vírgula:

```python
from ferramentas import tesoura, alicate
```

Uma outra maneira de obtermos todas as ferramentas é usando o `*`, neste caso, expressamos da seguinte forma:

```python
from ferramentas import *
```

Dessa forma temos todas as ferramentas em mãos e não precisamos usar o prefixo ferramentas quando desejarmos usá-las.

### Definindo Módulos

Vejamos agora como estes conceitos funcionam na prática, para isso vamos definir duas simples funções:

```python
def add(x, y):
	"""Recebe dois números x e y e retorna sua soma"""
	return x + y

def multiply(x, y):
	"""Recebe dois números x e y e retorna sua multiplicação"""
	return x * y
```

Salvamos ambas as funções em um arquivo de nome `modulo.py`, agora vamos criar um **novo arquivo** no mesmo diretório e **importaremos** nosso módulo para utilizá-lo:

```python
import modulo

print(modulo.add(4,5)) # 9
print(modulo.multiply(3,3)) # 9
```

Veja que utilizamos o comando **import** para buscarmos o nosso módulo e posteriormente **invocamos** as funções dele prefixando elas com a palavra **modulo**. 

### Importando Módulos

Imagine agora que temos um módulo chamado **matematica**. Os principais formatos para **importarmos** nossos módulos são:

```python
import matematica
```

- Tudo que está no módulo **matematica** é importado
- Para se referir aos métodos de matematica, adicionamos o prefixo "matematica" em frente ao seu nome

```python
matematica.nomeclasse.metodo()
matematica.funcao()
```

Importando usando o asterisco `*`:

```python
from matematica import *
```

- Tudo no módulo matematica é importado
- Para se referir a qualquer método no módulo, basta usar seu nome, sem precisarmos prefixar
- Lembre de ter atenção ao usar esse tipo de import, pois ele pode sobrescrever a definição de uma variável ou função já existente

```python
nomeclasse.metodo()
funcao()
```

Importando uma classe ou função específica:

```python
from matematica import nomeclasse
```

- Apenas o item **nomeclasse** será importado
- Após importar **nomeclasse** você pode usar ele sem o prefixo do módulo, ele é colocado no namespace atual
- Tome cuidado ao usar, pois pode sobrescrever a definição do nome, caso ele já esteja no namespace

```python
nomeclasse.metodo()
funcao()
```

Além de funções, os módulos também podem conter variáveis e estruturas de dados (listas, tuplas, dicionários, objetos). Vamos então criar mais um módulo para testarmos, nomearemos o nosso arquivo como `estudantes.py`.

```python
estudantes = [
	{'nome':'Uriel','idade':27,'aprovado':True},
	{'nome':'Emanuel','idade':25,'aprovado':True},
	{'nome':'Malthael','idade':29,'aprovado':False}
]

def imprimir_aprovados():
	for estudante in estudantes:
		if estudante['aprovado']:
			print(f'{estudante["nome"]} está aprovado')
```

Iremos agora importar o módulo **estudantes** e podemos acessar a lista de dicionários **estudantes**, perceba que fornecemos o mesmo nome para ambos, mas isso é uma escolha livre que temos. Também temos acesso a função para imprimir os estudantes que estão aprovados.

```python
from estudantes import *

estudante = estudantes[2]['nome']
print(estudante) # Malthael
```

Vamos agora invocar a função **imprimir()** para vermos quais estudantes estão aprovados:

```python
imprimir()
# Uriel está aprovado
# Emanuel está aprovado
```

Observe que usamos o `*` para importar o módulo por completo, por este motivo não foi necessário prefixarmos a função imprimir da seguinte forma `estudantes.imprimir()`.

### Nomeando um Módulo

Podemos dar um apelido para um módulo, tornando-o mais fácil de nos referirmos a ele, para isso usamos a palavra-chave **as**:

```python
import estudantes as e

print(e.estudantes[0]['idade']) # 27
e.imprimir()
# Uriel está aprovado
# Emanuel está aprovado
```

### Módulos Construídos do Python

Existem diversos módulos que já são construídos no Python e nós podemos importá-los quando quisermos sem a necessidade de instalação.

#### Módulo platform

O módulo [platform](https://docs.python.org/3/library/platform.html) nos permite o acesso aos dados de identificação da plataforma subjacente.

```python
import platform

s = platform.system()
print(s) # Linux
```

#### A função **dir()**

Existe uma função muito importante chamada **dir()** que lista todos os nomes das funções (e nome de atributos e variáveis) no módulo. 

Vamos testá-la com o módulo de [math](https://docs.python.org/3/library/math.html):

```python
import math

conteudo = dir(math)
print(conteudo) # ['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc']
```

Observe que nos é retornado uma grande quantidade de opções, entre atributos e funções, vejamos como podemos usar algumas delas.

Calculando a raiz quadrada de um número:

```python
print(math.sqrt(4)) # 2.0
```

Calculando o logaritmo na base 2 de um número:

```python
print(math.log2(8)) # 3.0
```

Calculando o logaritmo na base 10 de um número:

```python
math.log10(100) # 2.0
```

Calculando o máximo divisor comum entre dois números:

```python
math.gcd(50,85) # 5
```

Obtendo os valores de **pi** e **e**:

```python
print(math.e) # 2.718281828459045
print(math.pi) # 3.141592653589793
```

#### Módulo collections

Este módulo implementa tipos de dados de contêiner especializados, fornecendo alternativas aos contêineres integrados de uso geral do Python, **dict**, **list**, **set** e **tuple**.

Imagine que temos por exemplo uma lista com diversos itens repetidos:

```python
x = [1,1,1,2,2,3,3,5,9,9]
```

Desejamos contar o número de ocorrências de cada elemento desta lista, podemos usar o **Counter** do módulo [collections](https://docs.python.org/3/library/collections.html):

```python
from collections import Counter

Counter(x) # Counter({1: 3, 2: 2, 3: 2, 9: 2, 5: 1})
```

Um Counter é uma subclasse de **dict** para a contagem de objetos hashable. É uma coleção onde os elementos são armazenados como chaves de dicionário e suas contagens são armazenadas como valores de dicionário. As contagens podem ser qualquer valor inteiro, incluindo zero ou contagens negativas.

Observe que o número 1 ocorre 3 vezes, o 2 ocorre 2 e assim por diante.

Se quisermos saber os dois números com mais entradas, podemos utilizar o método **most_common()** passando como argumento o número 2:

```python
Counter(x).most_common(2) # [(1, 3), (2, 2)]
```

Nos será retornado uma lista de tuplas de pares de valores, neste caso indicando que o número 1 ocorre 3 vezes e o 2 apenas 2 vezes.

Como podemos ver os módulos nos permitem organizar o nosso código de maneira limpa e adequada e faz com que possamos trabalhar com bibliotecas do próprio **Python** e até mesmo outras feitas por terceiras pessoas, o que enriquece bastante o leque de possibilidades da linguagem **Python**.